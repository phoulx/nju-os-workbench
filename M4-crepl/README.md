# LAB - M4
https://jyywiki.cn/OS/2024/labs/M4.md  

## 思路

大致思路在文档里说得挺清楚  
不过有两点没讲（或者说我没明白，主要因为我对C的编译不熟）：  
一是如何编译，先创建新的C文件？  
二是如何调用之前的函数，编译时要将历史so都带上吗？  

理一下处理步骤：
1. 预处理
    1. 处理line，并判断是否为表达式
    2. 表达式则包装为函数，序号递增
    3. 新建临时.c文件，写入函数string
2. 编译
    1. fork子进程
    2. 子进程编译.c文件为.so文件，同样为临时文件
    3. 父进程等待子进程结束
    4. 根据返回值判断是否编译成功，失败则中止
3. 加载
    1. 使用dlopen加载.so文件
    2. 使用dlsym获取函数指针，并处理类型转换
    3. 通过函数指针调用函数

这里有个问题是，如果调用了之前定义的函数，如何找到它？想到几个方法：
- 每次都将前面的所有输入重复带到新的C文件，编译
- 编译的时候将前面所有的.so文件一起编译
- 准备一个.so文件数组，调用的时候，对数组中每个.so进行加载

前两个方法与优雅毫不相干，不必考虑  
第三个方法也不好实现，因为不确定需要调用的函数名（甚至可能调用多个函数）  
那最好是每次输入的时候，编译完就加载，可以放在内存。不过如果用`dlsym`需要函数名，这样仍要解析输入，感觉还是复杂了些  
最终找到了更好的方法：
- `dlopen`时添加参数`RTLD_GLOBAL`，该共享库中的函数即可直接被全局调用


## 实现注意点
1. 因为文件名和函数多次传来传去，索性用了结构体`Info`给必要的信息都包起来
2. 表达式和函数都需要立即加载，两者的区别在于是否要立刻调用


## 遗留问题
1. 没有用`mkstemp`API，因为末尾的文件扩展名修改不方便
2. 异常处理？
3. 既然已经全局加载了，那wrapper是否也不需要`dlsym`？


## 其他解答
网上没有找到特别好的解答，甚至看到有几个使用了上面提到的重复所有文本再编译的方法
