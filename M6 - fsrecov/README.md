# LAB - M6
https://jyywiki.cn/OS/2024/labs/M6.md  

## 思路
持久化是操作系统三个pieces中最麻烦的，因为要跟实际的存储设备打交道，没那么自由  

> jyy：这是一个阅读手册的训练

但我~~不想~~没足够的时间看FAT Specification，本实验打算以参考其他解答为主
目标是完成最小任务

最终还是没完全走捷径，看完了FAT Specs  
如jyy所说，不长，也比较好读  
不得不说FAT的一些设计挺蠢的，比如居然不能存奇数秒  
同样用32个bit表示时间，Unix时间戳就优雅多了


## FAT32文件系统
按`mkfs.fat -v -F 32 -S 512 -s 8 fs.img`格式化
little endian：以Byte为单位倒序
### 空间解析
整个空间分为3部分：保留区、FAT表（可能多份）、数据区
1. 保留区  
保留区占32个Sector，最重要的是#0（第一个）Sector，称为Boot Sector（512Bytes），其中核心是开头的BPB部分（大小64Bytes）  
#1 sector为FSInfo，以0x41615252开头（Specs上说FSInfo Copy会在#7 sector，但本例中无）  
#2-5 sector为空（填0）  
#6 sector为#0 sector的Copy  
#7-31 sector为空（填0）  

2. FAT表  
第一份位于0x4000，即#32 sector（512×32=0x4000）  
FAT Size = 0x10000 （可在BPB中查到）  
所以第二份FAT表在0x14000-0x23999  
FAT表从第8个Byte开始，每4个Byte为一条Entry，对应从簇号2开始  

3. 数据区  
紧挨着最後一份FAT表的结尾  
簇号从这里开始算（上面的保留区和FAT表，不管有多少sector都不算簇），从2算起  
数据在当前簇是否结束，要查对应的FAT Entry  

### 长文件名
看图  
主要信息还在短名

### 从根目录遍历
1. 读BPB，找到根目录的簇号（如2）
2. 找到簇号对应的数据，里面有目录的具体信息对应的簇号（如3）
3. 再到对应簇读取数据，依次遍历
这其中，FAT表的作用仅仅是在一个簇无法存下数据时，链向下一个簇


## Bitmap图片格式
整体分为头部+数据区，比较简单，直接看图
- 以424D开头
- 文件header包含filesize、宽、高、数据区偏移
- 数据区每3个Byte表示一个像素，每行的padding按4Byte补齐


### 初步理解
图片在FS中的存储，理想情况是连续的，可能会有部分图片分块
在FS格式化後，FAT表被清空，图片数据应保留原处

根据文档，大致的恢复流程如下：
1. 顺序扫描镜像的每个cluster
2. 标记数据，分类为4种之一：
    - 目录文件
    - BMP文件头部
    - BMP文件数据
    - 未使用
3. 根据手册恢复目录项，得到文件名和cluster ID
4. 匹配到对应的cluster，根据文件大小恢复
5. 对于破碎的文件或cluster，~~使用启发式算法找後继~~直接放弃？
6. 对每个恢复的文件，先写入，再调用popen读取并输出


再理一下
核心是找到目录项，再找对应簇，提取文件


### 困难解决
对于文件在非连续簇的情况，文档中给了有向图的解法
除了图算法不好做，求解差分（像素是否邻近）也比较困难
对于簇A、簇B，至少有两种不好处理的情况
- 簇A末尾像素恰好为图片一行的末尾像素
- 同一像素点的3个字节，被簇A簇B分开

所以先放弃了


遇到的一个不算问题的问题，就是用什么指针来表示一段目录项内存，可选项：
- void *
- u8 *
- struct fat32dent *
- struct fat32lfn *
- 用一个新的32字节的struct？



## 实现注意点


## 遗留问题


## 其他解答
以前，本实验名称为`frecov`，今年加了个`s`，搜索时可注意

