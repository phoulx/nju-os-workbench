# LAB - M1
https://jyywiki.cn/OS/2024/labs/M1.md  
本来以为很简单，结果在借助Copilot的情况还断断续续花了好几天。

/proc/pid下有很多文件，其中有父进程信息的有stat和status，这里用了後者  
思路在实验指导中说得比较清楚了，不过材料中如何打印出树状结构讲得比较简略，导致我开始以为甚至不用建树...  
搜了下网友的解答，发现不建树应该行不通，才踏踏实实考虑树结构。  
仔细想想，因为层级关系，肯定不能逐行打印，必然先将进程树存起来。

进程树是一棵多叉树，考虑到多叉树较复杂不好写，这里用到一个叫[Child-Sibling Representation](https://en.wikipedia.org/wiki/Left-child_right-sibling_binary_tree)的方法，用二叉树表示整个进程树。

确定了结点结构，接下来查找、打印、释放内存也就自然而然了（都用递归）。  
关于查找，考虑过几种方法：
- 用一个大数组（如`proc[32768]`），这样查找时间为O(1)，但太浪费空间了，而且进程ID可能很大（7位数以上）
- 哈希表，理论上效果应该不错，但我没用过C的哈希表，看得有点头大
- 结点增加一个字段next，将所有结点线性连接起来，变成链表。这样查找写起来会简单一点，但复杂度没变都是O(n)

看到不少网友将代码写得很复杂，我是希望尽量将代码写得工整、简洁（虽然可能还没能做到）。  
目前的实现有几个问题：
- 参数`-n`无效，因为默认已经按pid数字排好了（glibc中的`pstree`默认是pid名称字母顺序）。如果要同时支持字母序和数字序，树结构需要大改
- 打印的第一个子进程没有和父进程在同一行。如果要同一行，不能直接打印，得先存在buffer里，而且由于名称长短，间距不好把握
- 没有仔细考虑并发

另外自己做pstree的一个发现是，当前Linux发行版(我用的Debian 12 x86_64)中，并非所有进程都是`pid=1`的子进程，很多是`pid=2`的子进程。  
`pid=2`进程叫`kthread`，和`pid=1`(`systemd`)同是`pid=0`的子进程。
